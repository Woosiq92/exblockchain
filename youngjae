import hashlib
import json
from time import time
from urllib.parse import urlparse
import requests

from flask import Flask, request, jsonify
import json
from time import time
from textwrap import dedent
from uuid import uuid4

# Our blockchain.py API
from blockchain import util

####### block generation & its principle

class Blockchain(object):
	# initialize the blockchain info
	def __init__(self):
		self.chain = []
		self.current_transaction = []
		self.nodes = set()
		# genesis block
		self.new_block(previous_hash=1, proof=100)

	def new_block(self,proof,previous_hash=None):
		block = {
			'index': len(self.chain)+1,
			'timestamp': time(), # timestamp from 1970
			'transactions': self.current_transaction,
			'proof': proof,
			'previous_hash': previous_hash or self.hash(self.chain[-1])
		}
		self.current_transaction = []
		self.chain.append(block)
		return block

	def new_transaction(self,sender,recipient,amount):
		self.current_transaction.append(
			{
				'sender' : sender,
				'recipient' : recipient,
				'amount' : amount				
				
			}
		)
		return self.last_block['index'] + 1

	def register_node(self, address):
		parsed_url = urlparse(address)
		self.nodes.add(parsed_url.netloc) # netloc attribute! network lockation
	
	def valid_chain(self,chain):
		last_block = chain[0]
		current_index = 1
		
		while current_index < len(chain):
			block = chain[current_index]
			print('%s' % last_block)
			print('%s' % block)
			print("\n---------\n")
			# check that the hash of the block is correct
			if block['previous_hash'] != self.hash(last_block):
				return False
			last_block = block
			current_index += 1
		return True

	def resolve_conflicts(self):
		neighbours = self.nodes
		new_chain = None

		max_length = len(self.chain) # Our chain length
		for node in neighbours:
			tmp_url = 'http://' + str(node) + '/chain'
			response = requests.get(tmp_url)
			if response.status_code == 200:
				length = response.json()['length']
				chain = response.json()['chain']

				if length > max_length and self.valid_chain(chain):
					max_length = length

			if new_chain:
				self.chain = new_chain
				return True

			return False

	# directly access from class, share! not individual instance use it
	@staticmethod
	def hash(block):
		block_string = json.dumps(block, sort_keys=True).encode()
	
		return hashlib.sha256(block_string).hexdigest()

	@property
	def last_block(self):
		return self.chain[-1]

	def pow(self, last_proof):
		proof = 0
		while self.valid_proof(last_proof, proof) is False:
			proof += 1

		return proof

	@staticmethod
	def valid_proof(last_proof, proof):
		guess = str(last_proof + proof).encode()
		guess_hash = hashlib.sha256(guess).hexdigest()
		return guess_hash[:4] == "0000" # nonce
    



# /transactions/new : to create a new transaction to a block
# /mine : to tell our server to mine a new block.
# /chain : to return the full Blockchain.
# /nodes/register : to accept a list of new nodes in the form of URLs
# /nodes/resolve : to implement our Consensus Algorithm

app = Flask(__name__)
# Universial Unique Identifier
node_identifier = str(uuid4()).replace('-','')

blockchain = Blockchain()

@app.route('/mine',methods=['GET'])
def mine():
	last_block = blockchain.last_block
	last_proof = last_block['proof']

	proof = blockchain.pow(last_proof)
	# print "DEBUGGING!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
	blockchain.new_transaction(
			sender='0',
			recipient=node_identifier,
			amount=1 # coinbase transaction
	)
	# Forge the new Block by adding it to the chain
	previous_hash = blockchain.hash(last_block) # ??????????
	block = blockchain.new_block(proof, previous_hash)

	response = {
		'message' : 'new block found',
		'index' : block['index'],
		'transactions' : block['transactions'],
		'proof' : block['proof'],
		'previous_hash' : block['previous_hash']
	}

	return jsonify(response), 200

@app.route('/transactions/new', methods=['POST'])
def new_transaction():
	values = request.get_json()

	required = ['sender', 'recipient', 'amount']
	if not all(k in values for k in required):
		return 'missing values', 400
	
	# Create a new Transaction
	index = blockchain.new_transaction(values['sender'],values['recipient'],values['amount'])
	response = {'message' : 'Transaction will be added to Block {%s}' % index}
	
	return jsonify(response), 201

@app.route('/chain', methods=['GET'])
def full_chain():
	response = {
		'chain' : blockchain.chain,
		'length': len(blockchain.chain),
	}

	return jsonify(response), 200

@app.route('/nodes/register', methods=['POST'])
def register_nodes():
	values = request.get_json()

	nodes = values.get('nodes')
	if nodes is None: # Bad Request 400
		return "Error: Please supply a valid list of nodes", 400

	for node in nodes:
		blockchain.register_node(node)

	response = {
		'message' : 'New nodes have been added',
		'total_nodes': list(blockchain.nodes),
	}
	return jsonify(response), 201

@app.route('/nodes/resolve', methods=['GET'])
def consensus():
	replaced = blockchain.resolve_conflicts() # True False return

	if replaced:
		response = {
			'message' : 'Our chain was replaced',
			'new_chain' : blockchain.chain
		}
	else:
		response = {
			'message' : 'Our chain is authoritative',
			'chain' : blockchain.chain
		}
	return jsonify(response), 200

if __name__ == '__main__':
    app.run()
